"use strict";

exports.__esModule = true;
exports.loadAudioBuffer = loadAudioBuffer;

/**
 * Loads and decodes an audio-file, resulting in an AudioBuffer and the fileSize of the loaded file.
 * @param {AudioContext} context
 * @param {string} url
 * @param {(value: number) => void} onProgress
 * @returns {Promise<ILoadAudioBufferResult>}
 */
function loadAudioBuffer(context, url, onProgress) {
  return new Promise(function (resolve, reject) {
    var request = new XMLHttpRequest();
    request.open('GET', url, true);
    request.responseType = 'arraybuffer'; // listen to onprogress events if onProgress was supplied

    if (onProgress) {
      request.onprogress = function (event) {
        onProgress(event.loaded / event.total);
      };
    }

    request.onload = function () {
      if (request.status === 200) {
        var _fileSize = request.response.byteLength;
        var decodePromise = context.decodeAudioData(request.response, function (audioBuffer) {
          resolve({
            audioBuffer: audioBuffer,
            fileSize: _fileSize
          });
        }, function (error) {
          reject(error);
        }); // not all implementations use this promise (was later added to the API). if they do
        // we're catching (and ignoring) errors that may occur through here. these errors are
        // handled by the onError method in the decodeAudioData call (3rd param)

        if (decodePromise) {
          decodePromise.catch(function () {});
        }
      } else {
        reject("Error loading '" + url + "' (" + request.status + ")");
      }
    };

    request.onerror = function (error) {
      reject(error);
    };

    request.send();
  });
}